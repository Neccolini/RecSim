### 必要な機能

* 複数のルーチン（厳密には違うが以下ではスレッドと呼ぶ）を立て，それぞれがネットワークのノードとして動作する．
* 入力として，ノード数，トポロジー，ネットワークルーティング，テーブル更新方法などを設定したスクリプトのファイル名を受け取る
* 出力として，各チェックポイントでのノードの状態と，ネットワークの構成や各再構成にかかった時間を書き出す．
* あくまでもネットワークアルゴリズムの正当性を図るものであり，パケットロスは考えない（後で考えるかも）

総実行時間（ここでは実行サイクル）が決められており，それが経過するとすべてのスレッドが終了する．
スクリプト等で指示されたようにノードの取り外しや追加，再加入が行われる．
* 例：aサイクル後にノード1,2を取り外す
* 例：bサイクル後にノード5を追加する

スレッドが満たす条件
1. スレッド間でメッセージのやり取りができる
2. それぞれのスレッドが直接メッセージを送信できるスレッドの情報を保持できる（ルーティングテーブル）
3. すべてのスレッドがサイクルごとの同期をとる

メインルーチンが満たす条件
1. 各スレッドが隣接ブロードキャストをする面倒をみる
2. ノードの取り外し，追加に従い，全体の隣接リストを更新する
3. 1サイクルごとに情報を保存する

### 実装方針
* channelを用いて複数のgoroutinを立てる
* ルーチン同士のメッセージ交換はメインルーチンが面倒を見る
* 初期段階の実装では，1サイクル = ノードが一回の処理ループを終えるまで
  * 例えば パケットを受け取ってそれを次のノードにルーティングするまでは1サイクルで行われる．
* 1サイクルに二種類以上のパケットは送信できない(あとでできるようにするかも)
* ノード起動時に渡す情報
  * id, 生成するメッセージのリスト, ノードの種類
* 各サイクルでメインルーチン -> サブルーチンに渡す情報
  * cycle, id, message(別のノードからのメッセージ), ノードの更新情報, 
* 各サイクル終了時にサブルーチン -> メインルーチンに渡す情報
  * id, 送信したメッセージ
### 今後やること
1. 複数のgoroutineを生成してみる．
2. メインルーチンでそれぞれからメッセージを受け取る．
3. メインルーチンからそれぞれへメッセージを送る．
4. それぞれのgoroutineはメインルーチンを待ってから実行を再開するというのを実装する．

### 実装アルゴリズム
* 